---
title: "Low Level R"
format: html
---

## Types and classes 

### Types 
```{r}
typeof(1.5)
typeof("toto")
typeof('also between single quotes')
typeof(TRUE)
typeof(1L)
typeof(1)
typeof(typeof)
typeof(list())
```
What is a type ? In computer science, the way you can manipulate objects depends on objects type. If I manipulate a double (real numbers), I excepts the computer to provide me with usual operations on real numbers. 

Different types : 

-double -> real numbers
-integers -> integers when specified (if not specified it will be a double)
-character -> need to use libraries in R to do interesting with it
-logical -> TRUE or FALSE
-closure -> functions 
-list 


### Classes

Classes are your own types that you created on your computer, Types are your environment on your computer. 

```{r}
data(iris)
typeof(iris)
class(iris)
```
You can create a class from a list or a vector. 
What we have to understand is that we have operations that are available for types and that can be applied to classes. 

### Vectors 

#### Introduction

Many things in R are vectors (and most of the other things are lists). 
Everything is a vector but type is not vector since everything is, it is the type of elements of the vector. 

A vector is a collection of values of the same type (possibly a single value). 

```{r}
x <- 15.25
length(x)
x[1] #the way to access an element of a vector
length(length(x))
typeof(length(x))

y <- c(1, 2, 18.5)
length(y)
y[3]
typeof(y)
```
The c function can be seen as a creation function or, more accurately, as a vector concatenation function. 

#### Character vectors

This is not R strength ...

```{r}
z <- "Alice"
length(z)
```
The length of z is 1 because it is a vector of length 1. 

R isn't efficient to treat character Data, but you can use the package 'stringr'. 

```{r}
#install.packages("stringr")
library(stringr)
```
```{r}
str_length(z)
```
```{r}
complicated <- "ðŸ’ƒðŸ’ƒðŸ’ƒæˆ‘å–œæ¬¢é©¬"
complicated
length(complicated)
str_length(complicated)
```

```{r}
some_values <- c("ðŸ’ƒðŸ’ƒðŸ’ƒ", "æˆ‘å–œæ¬¢é©¬")
some_values
length(some_values)  #Gives the length of the vector
str_length(some_values)  #Gives a vector of the lengths
```

## INDEXING

```{r}
x <- c(6,4,7,12,21,0)
x[3]
```

```{r}
x[5] <- 89
```

The following sets y to be not the same thing but basically a copy of x:
```{r}
y <- x
```

```{r}
x[2] <- 33
```
x
y

Modifying x doesn't impact y (unlike in python and other programming languages). 

It is called a lazy copy: saying x and y are the same (y <- x) they actually are the same. But when I call the modification of one of the elements of either of them, a copy is created for the purpose. 

```{r}
x
x[c(2,2,1,4,5)]
```
This puts the number associated with each of the position written in c from x itself. 

```{r}
x[0]
```
Returns an empty numeric vector because index 0 has no meaning in R. 

```{r}
typeof(NA)
length(NA)
```

```{r}
typeof(NA_integer_)
```
Now the type is integer.

```{r}
x
x[c(4,1,0,15,6)]
```
`0` gets disregarded entirely, so no respective value is found in the new vector; `15` is not a position in x (that has 6 elements) and thus `NA` is printed instead. 

```{r}
y <- c('A', 'B', 'C')
y[c(TRUE, FALSE, FALSE)]
```

```{r}
x
x[c(-1,-4,-5)]
x[c(-2,-3,-6)]
```
We must use either positive indexes or negative ones. The negative indexes remove the value at that position.


```{r}
x
x[c(2,3,10)] <- c(7,88,190)
x
```
The vector gets enlarged so that he has the position needed (the biggest one required, in this case 10), and filled with `NAs` in the other missing positions. 



## LISTS 

```{r}
broken <- c(1L, 1.5, 'toto', FALSE)
broken
typeof(broken)
```
R tries to transform everything into one single type. 
This happens most often with the elements being converted into `character` type. 


### Creating a list
```{r}
bar <- list(1L, 1.4, 'toto', FALSE)
bar
```
Presentation is now different: we have double brakets for each element, then a vector is indicated. Indeed, `bar` gets printed as a list of vectors. (TO CHECK)


```{r}
foo <- list(c(1,2,3,TRUE,length))
foo
length(foo)
```
As we can see here, it may also be a list of objects other than vectors, as `length` in the last case.

```{r}
foo[[1]]
```
### Side steps - weird values 

```{r}
NA   ## missing value
NULL ## missing object 
NaN  ## not a number 
```

```{r}
0/0
1/0
-1/0
1/0 + 1
```
```{r}
foo[4]
```
Since there is no object at the 4th position. 

```{r}
x[5] <- c(2,1)
x
```
This does not work, because we are telling it to put a vector inside of a list. Something similar occurs with `list`:
```{r}
x[5] <- list(2,1)
x
```

So we have to do the following:
```{r}
x[5] <- list(c(2,1))
x
```

```{r}
y <- c(1,2,3)
y 
y[4]
y[4] <- c('toto')
```
This transforms everything into `character` type. 
```{r}
y <- c(1,2,3)
y[4] <- list(c('toto'))
```
This transforms `y` into a list, and now every element keeps its rightful type. 